
"""
C code to rebin or pick pixels out of 2D images

Rebinning and picking gain significant speedup from
loop fiddling and openmp


"""


from __future__ import print_function, division
import sys, time, os
from ctypes import  c_void_p, c_char, cdll, \
    c_uint8, c_uint16, c_uint32, c_uint64,  \
    c_int8,  c_int16,  c_int32,  c_int64,   \
    c_float, c_double, c_int
import numpy as np

if sys.platform.find("win32") >=0:
    extn = 'dll'
else:
    extn = 'so'

# Rebinning sizes and data types for unrolling loops
rebin_unroll       = [2,3,4,8]
#                        input       accumulator  ctype
rebin_unroll_types = [ ( "uint8_t" , "uint16_t", "uint8" ),
                       ( "uint16_t", "uint32_t", "uint16" ),
                       ( "int32_t" ,  "int64_t", "int32" ),
                       ( "float"   , "double"  , "float32" ) ]
    

def generate_C () :
    """
    # Generate the C code from a python script
    #  loops for types, unrolls loops
    """
    outputc = [ # list of strings to write to C file
    """
/* Automatically generated by
 * %s
 * on %s
 */
#include "img_simple.h"
#include <stdio.h>
#include <omp.h>

    """%( sys.argv[0], time.ctime()) ,
    ]

    outputh = [ # list of strings to write to header file
    """
/* Automatically generated by
 * %s
 * on %s
 */

#ifdef _MSC_VER	
#define restrict __restrict
#define DLL_EXPORT __declspec(dllexport)
#else
#define DLL_EXPORT 
#endif

#include <stdint.h>

    """%( sys.argv[0], time.ctime()) ,
    ]


    # Here the C code with loops unrolled:
    rebin = """
void rebin_%(t)s_%(n)s ( const %(t)s * restrict src, 
                         %(t)s * restrict dst, 
                         int dim0, int dim1 ){
    int odim0, odim1, ii, ji, io, jo;
    %(s)s t; // accumulator larger to avoid overflow
    odim0 = dim0/%(n)s;
    odim1 = dim1/%(n)s;
    // loop is on the output dimensions
#pragma omp parallel for private(ii,io,ji,jo,t)
    for( io = 0 ; io < odim0*odim1 ; io+=odim1 ){
      ii = (io/odim1)*dim1*%(n)s;
      for( jo = 0, ji=0 ; jo < odim1 ; jo++, ji+=%(n)s ){
	t = 0;
        // Generate by rebin_read_loop python code
        %(rebin_read_loop)s
        t = t / %(n)s / %(n)s ;
	dst[ io + jo ] = ( %(t)s ) t;
      }
    }
  }
"""
    def rebin_read_loop(n):
        """ Adds up the pixels in a bin """
        l = []
        for p in range(n):
            for q in range(n):
                l.append( """
        t += src[ ii + ji + %d*dim1 + %d ];"""%(p,q) )
        return "".join(l)
    
    # header code for rebin unrolled
    rebinh = """
void rebin_%(t)s_%(n)s ( const %(t)s * restrict , 
                         %(t)s * restrict, 
                         int , int  );
"""
    # maps to unrolled types
    for (t,s,p) in rebin_unroll_types:
        d = { 't' : t,
              's' : s }
        for i in rebin_unroll:
            d['rebin_read_loop'] = rebin_read_loop( i )
            d['n'] = str(i)
            outputc.append( rebin % d  )
            outputh.append( rebinh % d )
            
    # full looping version (bin size is variable)
    #   lots of bloat with all types possible
    rebin_any = """
void rebin_%(t)s ( const %(t)s * restrict src, 
                   %(t)s * restrict dst, 
                   int n,
                   int dim0, int dim1 ){
    int odim0, odim1;

    odim0 = dim0/n;
    odim1 = dim1/n;
#pragma omp parallel for 
    for( int i = 0 ; i < odim0*odim1 ; i+=odim1 ){
      int ii = (i/odim1)*dim1*n;
      %(s)s t;
      for( int j = 0 , ji = 0 ; j < odim1 ; j++, ji+=n ){
	t = 0;
        for( int p = 0 ; p < n ; p++ )
           for( int q = 0 ; q < n ; q++ )
              t+= src[ ii + p*dim1 + ji + q ];
        t = t / n / n ;
	dst[ i + j ] = ( %(t)s ) t;
      }
    }
  }
"""
    # header code
    rebinh_any = """
void rebin_%(t)s ( const %(t)s * restrict , 
                   %(t)s * restrict, 
                   int , int, int  );
"""
    # map out the generic versions
    for var in "int","uint":
        for t, s in ((8,16),(16,32),(32,64),(64,64)):
            d = { 't' : '%s%d_t'%(var,t),
                  's' : '%s%d_t'%(var,s) }
            outputc.append( rebin_any % d  )
            outputh.append( rebinh_any % d )
    for var in "float","double":
        d = { 't' : var,
              's' : 'double'}
        outputc.append( rebin_any % d  )
        outputh.append( rebinh_any % d )

    # Now for the pixel selecting code
    #  ... slower than numpy?
    pick = """
void pick_%(t)s ( const %(t)s * restrict src, %(t)s * restrict dst, int n,
		    int dim0, int dim1 ){
    int odim0, odim1, i, j, io, jo;
    // round up to get end of rows
    odim0 = (dim0+n-1)/n;
    odim1 = (dim1+n-1)/n;
    // avoid computes inside loops (only add)
    dim1*=n;
    for( i = 0 , io = 0 ; i < odim0*odim1 ; i+=odim1, io+=dim1 ){
      for( j = 0 , jo = 0 ; j < odim1 ; j++, jo+=n ){
	dst[ i + j ] = src[ io + jo ];
      }
    }
  }
"""

    for var in "int","uint":
        for t, s in ((8,16),(16,32),(32,64),(64,64)):
            d = { 't' : '%s%d_t'%(var,t) }
            outputc.append( pick % d  )
            
    for var in "float","double":
        d = { 't' : var }
        outputc.append( pick % d  )

    log2byteh = """
void log2byte( const uint16_t *restrict,
               uint8_t *restrict , int , int );
"""

    log2byte = """
void log2byte( const uint16_t *restrict src,
               uint8_t *restrict dst, int len, int imin ){
    /* Simple example to illustrate how the coded LUT should work */
    int i;
    uint16_t t, x;
    uint8_t n;
#pragma omp parallel private(t,x,n)
    for( i=0; i<len; i++){
       x = src[i] - imin;
       if   ( x <= 64 ){
          dst[i] = (uint8_t) x;
       } else if ( x <= 128u ){
          dst[i] = (uint8_t) ( x/2 + 32 );
       } else{ 
          // log2 x part : subtract 64 to match at 128:
          x -= 64;
          n = 0;
          t = x;
          while( t >>= 1) n++ ;
          // remainder after removing 2^n
          t = x - (1 << n);
          // minimal value for n here is 7, since 128 = 2^7
          dst[i] = (uint8_t) ( ( n << 4 ) + ( t  >> (n - 4) ) );
       }
    }
}
"""
    outputc.append( log2byte )
    outputh.append( log2byteh )

    log2bytesimdh = """
void log2bytesimd( const uint16_t *restrict,
                   uint8_t *restrict , int , int );
"""

    log2bytesimd = """
#include <assert.h>
#include <smmintrin.h>
#include <emmintrin.h>


#define is_aligned(POINTER, BYTE_COUNT) \
    (((uintptr_t)(const void *)(POINTER)) % (BYTE_COUNT) == 0)

#if defined (_MSC_VER)
#define OWORD_ALIGNMENT __declspec(align(16))
#else
#define OWORD_ALIGNMENT __attribute__ ((aligned (16))) 
#endif

typedef union OWORD_ALIGNMENT __oword {
  __m128i  m128i;
  __m128   m128;
  //  __m64i   m64i[2];
  __m64    m64[2];
  float    mf[4];
  int8_t   m128i_i8[16];
  int16_t  m128i_i16[8];
  int32_t  m128i_i32[4]; 
  int64_t  m128i_i64[2]; 
  uint8_t  m128i_u8[16];
  uint16_t m128i_u16[8];
  uint32_t m128i_u32[4];
  uint64_t m128i_u64[2];
} __oword;


void log2bytesimd( const uint16_t *restrict in,
                   uint8_t *restrict out, int len, int imin ){

  /* Nasty optimised code here ! from il2lut.c */
  /* dragons ! */

  assert( is_aligned(  in, 16));
  assert( is_aligned( out, 16));

  const __m128i vmin  = _mm_set1_epi16( imin );
  const __m128i v32   = _mm_set1_epi16( 32 );
  const __m128i v63  = _mm_set1_epi16( 63 );
  const __m128i v64  = _mm_set1_epi16( 64 );
  const __m128i v127  = _mm_set1_epi16( 127 );
  const __m128i v255  = _mm_set1_epi16( 0xFF );
  const __m128i v0   = _mm_set1_epi16( 0 );
  const __m128i mask0 = _mm_set_epi8(
    128u, 128u, 128u, 128u, 
    128u, 128u, 128u, 128u,
    14, 12, 10, 8, 
    6, 4, 2, 0);

#pragma omp parallel 
  {

    __m128i msk;
    __oword i0, o1, o2, n1, t1;

    int id  = omp_get_thread_num();
    int num = omp_get_num_threads();  

    // block size : must be aligned to memory for writes
    // len is 16*8 for writes
    int blck = len/16/num;
    int start = id*blck*16;
    int end = ( id == (num-1) ) ? len : start + blck*16;
    // Input 8 values
    for( int i = start ; i  < end ; i=i+8){
      // Load from memory
      i0.m128i = _mm_stream_load_si128( (__m128i *) &(in[i]) );
      // Take off the minimum (saturating)
      i0.m128i = _mm_subs_epu16(  i0.m128i, vmin ); // saturating subtract
      //  n =  (x >> 1) + 32;
      o2.m128i = _mm_srli_epi16(  i0.m128i, 1 );    // shift right adding zeros
      o2.m128i = _mm_adds_epu16(  o2.m128i, v32 );  // saturating add 32
      // x>=64 where x is unsigned
      // mask is 1 for gt64, 0 for less. 
      msk = _mm_cmpeq_epi16(
             _mm_srli_epi16(                   // shift right adding zeros
	      _mm_andnot_si128( v63,  i0.m128i ),  1), v0 );
      o2.m128i = _mm_blendv_epi8( o2.m128i, i0.m128i, msk );
      // Take off 64 for log part
      i0.m128i = _mm_subs_epu16(  i0.m128i, v64 ); // saturating subtract
      // mask is 1 for gt64, 0 for less.
      msk = _mm_cmpeq_epi16(
             _mm_srli_epi16(                   // shift right adding zeros
	      _mm_andnot_si128( v63,  i0.m128i ),  1), v0 );
      // take first 4 numbers as floats
      // https://stackoverflow.com/questions/9161807/sse-convert-short-integer-to-float/9169454
      o1.m128  = _mm_cvtepi32_ps( _mm_unpacklo_epi16( i0.m128i, v0));

      // e = np.right_shift((b-64).view(np.uint32),np.uint8(23))-127
      // f = np.right_shift((b-64).view(np.uint32),np.uint8(15))
      // g = np.reshape( np.frombuffer( f, dtype=np.uint8 ), (len(f), 4 ))
      //
      // def flog(a,e,g):
      // return np.where( a < 64, a,
      //                 np.where( a < 128, a/2 + 32,
      //                           e*16 + g[:,0]/16))
      
      // integer part of exponent
      n1.m128i = _mm_slli_epi32( 
                  _mm_subs_epu8(
		   _mm_srli_epi32( o1.m128i, 23 ), v127)  , 4 );
      // remainder part
      t1.m128i = _mm_srli_epi32(
		  _mm_and_si128(
		   _mm_srli_epi32( o1.m128i, 15 ), v255 ), 4);
      n1.m128i = _mm_add_epi32( n1.m128i, t1.m128i );
      
      // Now the second 4
      o1.m128  = _mm_cvtepi32_ps( _mm_unpackhi_epi16( i0.m128i, v0));
      i0.m128i = _mm_slli_epi32( _mm_subs_epu8( _mm_srli_epi32( 
                        o1.m128i, 23 ),  v127 )  , 4 );
      t1.m128i = _mm_srli_epi32( _mm_and_si128( _mm_srli_epi32( 
                        o1.m128i, 15 ),  v255 )  , 4 );
      t1.m128i = _mm_add_epi32( i0.m128i, t1.m128i );      
      // Combine the first and second 4 floats
      n1.m128i = _mm_packs_epi32 (n1.m128i, t1.m128i);
      // ... pick the ones above 128
      o2.m128i = _mm_blendv_epi8( n1.m128i, o2.m128i, msk );    
      // And put into output order
      o2.m128i = _mm_shuffle_epi8(o2.m128i, mask0);
      _mm_stream_pi( (__m64*) &(out[i]), _mm_movepi64_pi64(o2.m128i));
  } // endfor  
} // endparallel
}
"""
    outputc.append( log2bytesimd )
    outputh.append( log2bytesimdh )




    
    with open("img_simple.c","w") as f:
        f.write( ("".join( outputc )) )
        
    with open("img_simple.h","w") as f:
        f.write( ("".join( outputh )) )

    global extn
    print("Wrote C code, calling C compiler")
    sys.stdout.flush()
#    os.system("gcc -shared -fPIC -O3 -fopenmp -march=native -mtune=native -std=c99 -Wall img_simple.c -o _img_simple."+
 #             extn )
    # END of generateC

if __name__=="__main__":
    generate_C()
    sys.exit()
else:
    try:
        _lib = cdll.LoadLibrary("./_img_simple.so")
    except:
        _lib = cdll.LoadLibrary("_img_simple.dll")


rebin_funcs = { }
pick_funcs =  { }
def wrap(c_type, py_type):
    global rebin_funcs
    global pick_funcs
    f = getattr( _lib, "pick_%s"%(c_type) )
    f.argtypes = [ c_void_p, c_void_p, c_int, c_int, c_int ]
    pick_funcs[ py_type ] = f
    f = getattr( _lib, "rebin_%s"%(c_type) )
    f.argtypes = [ c_void_p, c_void_p, c_int, c_int, c_int ]
    rebin_funcs[ py_type ] = f

for var in "int","uint":
    for t in 8,16,32,64:
        c_type  = '%s%d_t'%(var,t)
        py_type = var+str(t)
        wrap( c_type, py_type )

wrap( "float", "float32" )
wrap( "double", "float64" )

for (t,s,p) in rebin_unroll_types:
    for i in rebin_unroll:
        f = getattr( _lib, "rebin_%s_%d"%(t, i) )
        f.argtypes = [ c_void_p, c_void_p, c_int, c_int ]
        rebin_funcs[ (i,p) ] = f

_log2byte = _lib.log2byte
_log2byte.argtypes = [ c_void_p, c_void_p, c_int, c_int ]

_log2bytesimd = _lib.log2bytesimd
_log2bytesimd.argtypes = [ c_void_p, c_void_p, c_int, c_int ]

def log2byte( ar, minval = 64, out = None ):
    assert ar.dtype == np.uint16
    ar = np.require( ar, dtype=np.uint16,
                     requirements=['C_CONTIGUOUS', 'ALIGNED'] )
    if out is None:
        out = np.zeros( ar.shape, np.uint8 )
    else:
        assert (out.dtype == np.uint8)
        assert (out.shape == ar.shape)
    _log2byte( ar.ctypes.data,
               out.ctypes.data,
               out.nbytes,
               minval   )
    return out

def log2bytesimd( ar, minval = 64, out = None ):
    assert ar.dtype == np.uint16
    ar = np.require( ar, dtype=np.uint16,
                     requirements=['C_CONTIGUOUS', 'ALIGNED'] )
    if out is None:
        out = np.zeros( ar.shape, np.uint8 )
    else:
        assert (out.dtype == np.uint8)
        assert (out.shape == ar.shape)
    _log2bytesimd( ar.ctypes.data,
                   out.ctypes.data,
                   out.nbytes,
                   minval   )
    return out


    
def rebin( ar, n, out=None):
    """
    ar = input array
    n is an integer
    """
    ar = np.require( ar , requirements=['C_CONTIGUOUS', 'ALIGNED'] )
    assert len(ar.shape)==2
    if out is None:
        out = np.empty( [ i//n for i in ar.shape ], ar.dtype )
    else:
        assert len(out.shape)==2
        for i,j in zip(ar.shape,out.shape):
            assert j == i//n
    
    if n in rebin_unroll and (n, ar.dtype.name) in rebin_funcs.keys():
        rebin_funcs[ (n, ar.dtype.name) ]( ar.ctypes.data,
                                           out.ctypes.data,
                                           ar.shape[0],
                                           ar.shape[1] )
    else:
        rebin_funcs[ (ar.dtype.name) ]( ar.ctypes.data,
                                        out.ctypes.data,
                                        n,
                                        ar.shape[0],
                                        ar.shape[1] )
    return out

def pick( ar, n, out=None):
    """
    ar = input array
    n is an integer
    """
    ar = np.ascontiguousarray( ar )
    assert len(ar.shape)==2
    if out is None:
        # round up as picks only the lowest corner
        # not i//n!!
        out = np.empty( [ (i+n-1)//n for i in ar.shape ], ar.dtype )
    else:
        assert len(out.shape)==2
        for i,j in zip(ar.shape,out.shape):
            assert j == i//n
    pick_funcs[ ar.dtype.name ]( ar.ctypes.data,
                                 out.ctypes.data,
                                 n,
                                 ar.shape[0],
                                 ar.shape[1],
                                  )
    return out
    

__all__=[ 'rebin', 'pick', 'log2byte' ]


    
