
from __future__ import print_function, division
import sys, time, os
from ctypes import  c_void_p, c_char, cdll, \
    c_uint8, c_uint16, c_uint32, c_uint64,  \
    c_int8,  c_int16,  c_int32,  c_int64,   \
    c_float, c_double, c_int
import numpy as np

if sys.platform.find("win32") >=0:
    extn = 'dll'
else:
    extn = 'so'

rebin_unroll = [2,3,4,8,16]
    

def generate_C () :
    # Generate the C code from a python script
    #  loop for types

    outputc = [
    b"""
/* Automatically generated by
 * %s
 * on %s
 */
#include "img_simple.h"
#include <stdio.h>

    """%( sys.argv[0], time.ctime()) ,
    ]


    outputh = [
    b"""
/* Automatically generated by
 * %s
 * on %s
 */

#ifdef _MSC_VER	
#define restrict __restrict
#define DLL_EXPORT __declspec(dllexport)
#else
#define DLL_EXPORT 
#endif

#include <stdint.h>

    """%( sys.argv[0], time.ctime()) ,
    ]



    rebin = b"""
void rebin_%(t)s_%(n)s ( const %(t)s * restrict src, 
                         %(t)s * restrict dst, 
                         int dim0, int dim1 ){
    int odim0, odim1, i, j;
    %(s)s t;
    odim0 = dim0/%(n)s;
    odim1 = dim1/%(n)s;
    for( i = 0 ; i < odim0 ; i++ ){
      for( j = 0 ; j < odim1 ; j++ ){
	t = 0;
        %(rebin_read_loop)s
        t = t / %(n)s / %(n)s ;
	dst[ i*odim1 + j ] = ( %(t)s ) t;
      }
    }
  }
"""
    def rebin_read_loop(n):
        l = []
        for p in range(n):
            for q in range(n):
                l.append( """
        t += src[ (i*%d+%d)*dim1 + (j*%d+%d) ];"""%(n,p,n,q) )
        return "".join(l)

    rebinh = """
void rebin_%(t)s_%(n)s ( const %(t)s * restrict , 
                         %(t)s * restrict, 
                         int , int  );
"""
    
    for var in "int","uint":
        for t, s in ((8,16),(16,32),(32,64),(64,64)):
            d = { 't' : '%s%d_t'%(var,t),
                  's' : '%s%d_t'%(var,s) }
            for i in rebin_unroll:
                d['rebin_read_loop'] = rebin_read_loop( i )
                d['n'] = str(i)
                outputc.append( rebin % d  )
                outputh.append( rebinh % d )
    for var in "float","double":
        for i in rebin_unroll:
            d = { 't' : var,
                  's' : 'double',
                  'rebin_read_loop' : rebin_read_loop( i ),
                  'n' : str(i) }
            outputc.append( rebin % d  )
            outputh.append( rebinh % d )
    
    # full loop version 
    rebin_any = b"""
void rebin_%(t)s ( const %(t)s * restrict src, 
                   %(t)s * restrict dst, 
                   int n,
                   int dim0, int dim1 ){
    int odim0, odim1, i, j, p, q;
    %(s)s t;
    odim0 = dim0/n;
    odim1 = dim1/n;
    for( i = 0 ; i < odim0 ; i++ ){
      for( j = 0 ; j < odim1 ; j++ ){
	t = 0;
        for( p = 0 ; p < n ; p++ )
           for( q = 0 ; q < n ; q++ )
              t+= src[ (i+p)*dim1 + (j+q) ];
        t = t / n / n ;
	dst[ i*odim1 + j ] = ( %(t)s ) t;
      }
    }
  }
"""
    rebinh_any = """
void rebin_%(t)s ( const %(t)s * restrict , 
                   %(t)s * restrict, 
                   int , int, int  );
"""

    for var in "int","uint":
        for t, s in ((8,16),(16,32),(32,64),(64,64)):
            d = { 't' : '%s%d_t'%(var,t),
                  's' : '%s%d_t'%(var,s) }
            outputc.append( rebin_any % d  )
            outputh.append( rebinh_any % d )
    for var in "float","double":
        d = { 't' : var,
              's' : 'double'}
        outputc.append( rebin_any % d  )
        outputh.append( rebinh_any % d )



            
    pick = """
void pick_%(t)s ( const %(t)s * restrict src, %(t)s * restrict dst, int n,
		    int dim0, int dim1 ){
    int odim0, odim1, i, j;
    odim0 = (dim0+n-1)/n;
    odim1 = (dim1+n-1)/n;
/*    printf("In pick_%(t)s : n=%%d, dim0=%%d dim1=%%d odim0=%%d odim1==%%d\\n",
       n, dim0, dim1, odim0, odim1 ); */
    for( i = 0 ; i < odim0 ; i++ ){
      for( j = 0 ; j < odim1 ; j++ ){
	dst[ i*odim1 + j ] = src[ i*n*dim1 + j*n ];
      }
    }
  }
"""

    for var in "int","uint":
        for t, s in ((8,16),(16,32),(32,64),(64,64)):
            d = { 't' : '%s%d_t'%(var,t) }
            outputc.append( pick % d  )
            
    for var in "float","double":
        d = { 't' : var }
        outputc.append( pick % d  )

    with open("img_simple.c","w") as f:
        f.write( ("".join( outputc )).encode('utf-8') )
        
    with open("img_simple.h","w") as f:
        f.write( ("".join( outputh )).encode('utf-8') )

    global extn
    print("Wrote C code, calling C compiler")
    sys.stdout.flush()
    os.system("gcc -shared -fPIC -O3 -msse4.2 -std=c99 -Wall img_simple.c -o _img_simple."+
              extn )
    # END of generateC

if __name__=="__main__":
    generate_C()
    sys.exit()
else:
    try:
        _lib = cdll.LoadLibrary("./_img_simple.so")
    except:
        _lib = cdll.LoadLibrary("_img_simple.dll")


rebin_funcs = { }
pick_funcs =  { }
def wrap(c_type, py_type):
    global rebin_funcs
    global pick_funcs
    f = getattr( _lib, "pick_%s"%(c_type) )
    f.argtypes = [ c_void_p, c_void_p, c_int, c_int, c_int ]
    pick_funcs[ py_type ] = f
    for i in rebin_unroll:
        f = getattr( _lib, "rebin_%s_%d"%(c_type, i) )
        f.argtypes = [ c_void_p, c_void_p, c_int, c_int ]
        rebin_funcs[ (i,py_type) ] = f
    f = getattr( _lib, "rebin_%s"%(c_type) )
    f.argtypes = [ c_void_p, c_void_p, c_int, c_int, c_int ]
    rebin_funcs[ py_type ] = f

for var in "int","uint":
    for t in 8,16,32,64:
        c_type  = '%s%d_t'%(var,t)
        py_type = var+str(t)
        wrap( c_type, py_type )

wrap( "float", "float32" )
wrap( "double", "float64" )
        

def rebin( ar, n, out=None):
    """
    ar = input array
    n is an integer
    """
    ar = np.ascontiguousarray( ar )
    assert len(ar.shape)==2
    if out is None:
        out = np.empty( [ i//n for i in ar.shape ], ar.dtype )
    else:
        assert len(out.shape)==2
        for i,j in zip(ar.shape,out.shape):
            assert j == i//n
    if n in rebin_unroll:
        rebin_funcs[ (n, ar.dtype.name) ]( ar.ctypes.data,
                                           out.ctypes.data,
                                           ar.shape[0],
                                           ar.shape[1] )
    else:
        rebin_funcs[ (ar.dtype.name) ]( ar.ctypes.data,
                                        out.ctypes.data,
                                        n,
                                        ar.shape[0],
                                        ar.shape[1] )
    return out

def pick( ar, n, out=None):
    """
    ar = input array
    n is an integer
    """
    ar = np.ascontiguousarray( ar )
    assert len(ar.shape)==2
    if out is None:
        # round up as picks only the lowest corner
        # not i//n!!
        out = np.empty( [ (i+n-1)//n for i in ar.shape ], ar.dtype )
    else:
        assert len(out.shape)==2
        for i,j in zip(ar.shape,out.shape):
            assert j == i//n
    pick_funcs[ ar.dtype.name ]( ar.ctypes.data,
                                 out.ctypes.data,
                                 n,
                                 ar.shape[0],
                                 ar.shape[1],
                                  )
    return out
    

__all__=[ 'rebin', 'pick' ]


    
